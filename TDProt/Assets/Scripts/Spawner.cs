// Spawner.cs
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Spawner : MonoBehaviour
{
    [Header("Level")]
    public float levelLength = 180f;
    public AnimationCurve budgetCurve = AnimationCurve.EaseInOut(0, 0, 1, 1);
    public float budgetStart = 5f;
    public float budgetEnd = 200f;
    public float tickInterval = 1f;

    [Header("Spawn Limits")]
    public bool accumulateBudget = true;      // true = ?????? ?????????????; false = ?????? = targetBudget ?????? ????????
    public int totalSpawnLimit = 60;         // ???? ?????? ?? ??????? (0 = ?????????????)
    public float minSpawnInterval = 0.12f;   // ??????????? ????? ????? ?????????? ???????? (???)
    private int totalSpawnedCount = 0;
    private float lastSpawnTime = -999f;

    [Header("Spawn")]
    public Transform[] spawnPoints;
    public EnemyType[] enemyTypes;
    public int maxConcurrent = 40;
    public int maxPerTick = 6;
    public float spawnDelayBetween = 0.12f;

    private float elapsed = 0f;
    private float currentBudget = 0f;
    private Dictionary<EnemyType, SimplePool> pools = new Dictionary<EnemyType, SimplePool>();
    private int activeEnemies = 0;

    void Start()
    {
        // ??????? ???????? ????
        foreach (var et in enemyTypes)
        {
            var go = new GameObject("Pool_" + et.name);
            go.transform.SetParent(transform);
            var p = go.AddComponent<SimplePool>();
            p.Init(et.prefab, 6);
            pools[et] = p;


        }

        StartCoroutine(LevelLoop());
    }

    IEnumerator LevelLoop()
    {
        float tickTimer = 0f;
        while (elapsed < levelLength)
        {
            float dt = Time.deltaTime;
            elapsed += dt;
            tickTimer += dt;

            if (tickTimer >= tickInterval)
            {
                tickTimer = 0f;
                float tNorm = Mathf.Clamp01(elapsed / levelLength);
                float curveVal = budgetCurve.Evaluate(tNorm);
                float targetBudget = Mathf.Lerp(budgetStart, budgetEnd, curveVal);

                if (accumulateBudget)
                {
                    currentBudget += targetBudget * (tickInterval / 1f);
                }
                else
                {
                    // ?? ??????????? — ??????? ?????? ????? "????????" ???????? ??????
                    currentBudget = targetBudget;
                }

                // ?????????????? ??????: ?? ???? ??????? ??????????? ??????? ???????
                currentBudget = Mathf.Min(currentBudget, budgetEnd * 1.5f);

                // ????????? ??????? ??????
                StartCoroutine(AttemptSpawnBurst());
            }

            yield return null;
        }

        // ?? ?????????? ?????? — ????? ?????????? ????/??????????
        LevelManager.Instance?.SetAllEnemiesSpawned();
    }

    IEnumerator AttemptSpawnBurst()
    {
        if (activeEnemies >= maxConcurrent) yield break;
        if (totalSpawnLimit > 0 && totalSpawnedCount >= totalSpawnLimit) yield break;

        int spawned = 0;
        int attempts = 0;
        // ????? ??????? ??????, ????? ?? ???????? ? ??????????? ????? ??? ??????? ??????
        while (currentBudget > 0f && spawned < maxPerTick && activeEnemies < maxConcurrent && attempts < 50)
        {
            attempts++;
            // ????????? ?????????? ?????
            if (totalSpawnLimit > 0 && totalSpawnedCount >= totalSpawnLimit) break;

            // rate-limit: ???? ?????? ???? ??????? ? ?????????? ??????, ????????
            if (Time.time - lastSpawnTime < minSpawnInterval)
            {
                // ????????? ?? ?????????????? ?????????
                float wait = (minSpawnInterval - (Time.time - lastSpawnTime));
                yield return new WaitForSeconds(wait);
            }

            var et = ChooseEnemyType();
            if (et == null) break;
            if (currentBudget < et.cost)
            {
                // ???? ?????? ?? ??????? ??? ?????????? ????, ??????? ??????? ?????? (??? ?????)
                // ??????? ??????: ????????? weight ???????? — ?? ?????: ???????? attempts ? ?????????
                continue;
            }

            var sp = spawnPoints[Random.Range(0, spawnPoints.Length)];
            var pool = pools[et];
            var go = pool.Get(sp.position);
            var enemy = go.GetComponent<Enemy>();
            if (enemy != null)
            {
                enemy.InitFromType(et, pool, this);
                LevelManager.Instance?.RegisterSpawnedEnemy(enemy);
            }

            currentBudget -= et.cost;
            activeEnemies++;
            totalSpawnedCount++;
            lastSpawnTime = Time.time;

            spawned++;

            // ????? ?????????? ?? ???????? ?????? ????? — ????????????? ? minSpawnInterval
            yield return new WaitForSeconds(Mathf.Max(spawnDelayBetween, minSpawnInterval));
        }
    }


    EnemyType ChooseEnemyType()
    {
        float tNorm = Mathf.Clamp01(elapsed / levelLength);
        // ???????? ?????????? ? ????????? ???
        int totalW = 0;
        List<EnemyType> candidates = new List<EnemyType>();
        foreach (var e in enemyTypes)
        {
            if (tNorm * levelLength < e.unlockTime) continue; // ??? ?? ??????
            int w = Mathf.Max(1, e.weight);
            totalW += w;
            for (int i = 0; i < w; i++) candidates.Add(e);
        }

        if (candidates.Count == 0) return null;
        return candidates[Random.Range(0, candidates.Count)];
    }

    // ?????????? ?? Enemy ??? ??????/?????????? ? ???, ???? ??????
    public void NotifyEnemyDead()
    {
        activeEnemies = Mathf.Max(0, activeEnemies - 1);
    }
}
